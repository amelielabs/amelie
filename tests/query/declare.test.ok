open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }]
connect E0 S0 127.0.0.1:3485
# test: declare parsing
declare
{"msg": "declare ⟵ name expected"}
declare 1
{"msg": "declare ❰1❱ ⟵ name expected"}
declare name
{"msg": "declare name ⟵ unrecognized data type"}
# test: declare
declare a int
declare a int;
explain declare a int;
{"msg": "❰explain❱ ⟵ EXPLAIN without command"}
# test: declare begin/end
declare a int; begin; select a; end;
{"msg": "declare a int; begin❰;❱ ⟵ unsupported statement"}
explain begin; declare a int; select a; end;
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "var                 0      0      0     ",
      "02": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
begin; declare a int; select a; end;
[null]
# test: declare default
explain declare a int; select a
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "var                 0      0      0     ",
      "02": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare a int; select a
[null]
explain declare a int; declare b int; select a, b
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          2      0      0     ",
      "01": "set                 0      2      0     ",
      "02": "var                 1      0      0     ",
      "03": "push                1      0      0     ",
      "04": "var                 1      1      0     ",
      "05": "push                1      0      0     ",
      "06": "set_add             0      0      0     ",
      "07": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare a int; declare b int; select a, b
[[null, null]]
declare a int; declare b json; select a::type, b::type
[["null", "null"]]
# test: declare redefine
declare a int; declare a int;
{"msg": "declare a int; declare ❰a❱ ⟵ variable redefined"}
# test: declare null
declare a null;
{"msg": "declare a ❰null❱ ⟵ unrecognized data type"}
# test: := operator parsing
:=
{"msg": ":= ⟵ unexpected statement"}
0 :=
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
0 := 0
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
'x' := 1
{"msg": "'x' ❰:=❱ ⟵ unexpected statement"}
x :=
{"msg": "x := ⟵ bad expression"}
# test: := expr
x := 1
{"msg": "x := 1 ⟵ variable 'x' not found"}
explain x := 1
{"msg": "explain x := 1 ⟵ variable 'x' not found"}
declare x int; x := 1
explain declare x int; x := 1
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "int                 0      -      0     # 1",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "ret                 -1     -1     -     "
    }
  },
  "access": []
}]
# test: := expr
declare x int; x := 1; select x
[1]
explain declare x int; x := 1; select x
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "int                 0      -      0     # 1",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare x int; declare y int; x := 1; y := 2; select x + y
[3]
# test: := expr (json)
declare x json; x := {"id": 48}; select x.id
[48]
explain declare x json; x := {"id": 48}; select x.id
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "json                0      0      0     ",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "string              1      7      0     # id",
      "06": "dotjs               2      0      1     ",
      "07": "ret                 2      -1     -     "
    }
  },
  "access": []
}]
# test: := expr (null)
declare x int; x := null; select x
[null]
explain declare x int; x := null; select x
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "null                0      0      0     ",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare x int; x := null; select x + 10
[null]
# test: := expr (column shadow)
create table test (id int primary key)
insert into test values (1)
explain  declare id int; id := 1; select * from test where id = id
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "int                 0      -      0     # 1",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "push_ref            0      0      0     ",
      "06": "var                 0      0      0     ",
      "07": "push_ref            0      0      0     ",
      "08": "union               0      0      0     ",
      "09": "send_all            0      -      0     # public.test (last)",
      "10": "union_recv          0      0      0     ",
      "11": "union_set           0      0      -1    ",
      "12": "ret                 0      -1     -     "
    },
    "backend": {
      "00": "set                 0      1      0     ",
      "01": "table_open_part     1      0      10    # public.test (primary)",
      "02": "ref                 2      0      0     ",
      "03": "ref                 3      1      0     ",
      "04": "equii               4      2      3     ",
      "05": "jntr                9      4      0     ",
      "06": "table_readi32       2      1      0     ",
      "07": "push                2      0      0     ",
      "08": "set_add             0      0      0     ",
      "09": "table_next          1      2      0     ",
      "10": "free                1      0      0     ",
      "11": "ret                 0      -1     -     "
    }
  },
  "access": [["public.test", "ro"]]
}]
declare id int; id := 1; select * from test where id = id
[1]
explain declare id int; id := 1; select * from test where test.id = id
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "int                 0      -      0     # 1",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "push_ref            0      0      0     ",
      "06": "union               0      0      0     ",
      "07": "var                 1      0      0     ",
      "08": "push                1      0      0     ",
      "09": "send_lookup_by      0      -      -     # public.test (last)",
      "10": "union_recv          0      0      0     ",
      "11": "union_set           0      0      -1    ",
      "12": "ret                 0      -1     -     "
    },
    "backend": {
      "00": "set                 0      1      0     ",
      "01": "ref                 1      0      0     ",
      "02": "push                1      0      0     ",
      "03": "table_open_partl    1      0      11    # public.test (primary)",
      "04": "table_readi32       2      1      0     ",
      "05": "ref                 3      0      0     ",
      "06": "equii               4      2      3     ",
      "07": "jntr                11     4      0     ",
      "08": "table_readi32       2      1      0     ",
      "09": "push                2      0      0     ",
      "10": "set_add             0      0      0     ",
      "11": "free                1      0      0     ",
      "12": "ret                 0      -1     -     "
    }
  },
  "access": [["public.test", "ro"]]
}]
declare id int; id := 1; select * from test where test.id = id
[1]
drop table test
# test: insert returning into (1 column)
create table test (id int primary key)
insert into test values (1), (2), (3), (4)
# test: var pushdown
declare x int; x := 1; select * from test where id = x
[1]
explain declare x int; x := 1; select * from test where id = x
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "int                 0      -      0     # 1",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "var                 0      0      0     ",
      "05": "push_ref            0      0      0     ",
      "06": "union               0      0      0     ",
      "07": "var                 1      0      0     ",
      "08": "push                1      0      0     ",
      "09": "send_lookup_by      0      -      -     # public.test (last)",
      "10": "union_recv          0      0      0     ",
      "11": "union_set           0      0      -1    ",
      "12": "ret                 0      -1     -     "
    },
    "backend": {
      "00": "set                 0      1      0     ",
      "01": "ref                 1      0      0     ",
      "02": "push                1      0      0     ",
      "03": "table_open_partl    1      0      11    # public.test (primary)",
      "04": "table_readi32       2      1      0     ",
      "05": "ref                 3      0      0     ",
      "06": "equii               4      2      3     ",
      "07": "jntr                11     4      0     ",
      "08": "table_readi32       2      1      0     ",
      "09": "push                2      0      0     ",
      "10": "set_add             0      0      0     ",
      "11": "free                1      0      0     ",
      "12": "ret                 0      -1     -     "
    }
  },
  "access": [["public.test", "ro"]]
}]
# test: := with cte
declare x int; x := with a as (select 1) select * from a; select x
{"msg": "declare x int; x := ❰with❱ ⟵ bad expression"}
# test: := with cte (assign inside)
declare x int; with a as (x := select 1) select * from a; select x
{"msg": "declare x int; with a as (x ❰:=❱ ⟵ unexpected statement"}
drop table test
# test: := ddl
declare x json; x := show all;
{"msg": "declare x json; x := ❰show❱ ⟵ bad expression"}
# test: declare := select expr
declare x int := select 1
{"msg": "declare x int := ❰select❱ ⟵ unexpected subquery"}
explain declare x int := select 1
{"msg": "explain declare x int := ❰select❱ ⟵ unexpected subquery"}
# test: select into (not defined)
select 1 into x; select x
{"msg": "select 1 into x❰;❱ ⟵ variable 'x' not found"}
# test: select into
declare x int; select 1 into x; select x
[1]
# test: select into (redefine)
declare x int; select 1 into x; select 2 into x; select x
[2]
declare x int; x := 1; select 2 into x; select x
[2]
# test: select into (cte)
with a as (select 1 into x) select * from a
{"msg": "with a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
declare x int; with a as (select 1 into x) select * from a
{"msg": "declare x int; with a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
# test: select into (subquery)
declare x int; select (select 1 into x); select x
{"msg": "declare x int; select (select 1 ❰into❱ ⟵ INTO cannot be used inside subquery"}
# test: select into (var)
declare x int; x := select 1 into x; select x
{"msg": "declare x int; x := ❰select❱ ⟵ unexpected subquery"}
# test: insert returning into (1 column)
create table test (id int primary key)
declare x int; insert into test values (1) returning id into x; select x
[1]
# test: insert returning into (2 columns, 1 into)
declare x int; insert into test values (2) returning id, id into x; select x
[2]
# test: insert returning into (2 columns, 2 into)
declare x int; declare y int; insert into test values (3) returning id, id + 10 into x, y; select x, y
[[3, 13]]
# test: insert returning into (2 columns, 2 into rewrite)
declare x int; insert into test values (4) returning id, id + 10 into x, x; select x
[14]
drop table test
# test: select from var
explain declare x json := [1,2,3]; select * from x as it;
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "json                0      0      0     ",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "set                 0      1      0     ",
      "05": "var                 1      0      0     ",
      "06": "json_open           2      1      11    ",
      "07": "json_read           3      2      0     ",
      "08": "push                3      0      0     ",
      "09": "set_add             0      0      0     ",
      "10": "json_next           2      7      0     ",
      "11": "free                2      0      0     ",
      "12": "free                1      0      0     ",
      "13": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from x as it;
[1, 2, 3]
explain declare x json := [1,2,3]; select * from (x) as it;
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "json                0      0      0     ",
      "02": "var_set             0      0      0     ",
      "03": "free                0      0      0     ",
      "04": "set                 0      1      0     ",
      "05": "var                 1      0      0     ",
      "06": "json_open           2      1      11    ",
      "07": "json_read           3      2      0     ",
      "08": "push                3      0      0     ",
      "09": "set_add             0      0      0     ",
      "10": "json_next           2      7      0     ",
      "11": "free                2      0      0     ",
      "12": "free                1      0      0     ",
      "13": "ret                 0      -1     -     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from (x) as it;
[1, 2, 3]
# test: declare table parsing
declare x table
{"msg": "declare x table ⟵ ( expected"}
declare x table 1
{"msg": "declare x table ❰1❱ ⟵ ( expected"}
declare x table (
{"msg": "declare x table ( ⟵ name expected"}
declare x table ()
{"msg": "declare x table (❰)❱ ⟵ name expected"}
declare x table (id
{"msg": "declare x table (id ⟵ unrecognized data type"}
declare x table (id int
{"msg": "declare x table (id int ⟵ ) expected"}
# test: declare table
create table test (id int primary key)
insert into test values (1), (2), (3)
declare x table (id int); select x::type
["null"]
declare x table (id int); select 123 into x; select x
[123]
declare x table (id int); select * into x from test; select x::type
["store"]
declare x table (id int); select * into x from test; select x
[1, 2, 3]
drop table test
# test: select into table (mismatch)
create table test (id int primary key, data int)
insert into test values (1, 1), (2, 2), (3, 3)
declare x table (a int, b int); select id into x from test;
{"msg": "declare x table (a int, b int); ❰select❱ ⟵ variable table columns mismatch"}
# test: select into table
explain declare x table (a int, b int); select * into x from test; select * from x
[{
  "bytecode": {
    "frontend": {
      "00": "push_nulls          1      0      0     ",
      "01": "union               0      0      0     ",
      "02": "send_all            0      -      0     # public.test (last)",
      "03": "union_recv          0      0      0     ",
      "04": "union_set           0      0      -1    ",
      "05": "var_mov             0      0      0     ",
      "06": "set                 0      2      0     ",
      "07": "var                 1      0      0     ",
      "08": "store_open          2      1      15    ",
      "09": "store_read          3      2      0     ",
      "10": "push                3      0      0     ",
      "11": "store_read          3      2      1     ",
      "12": "push                3      0      0     ",
      "13": "set_add             0      0      0     ",
      "14": "store_next          2      9      0     ",
      "15": "free                2      0      0     ",
      "16": "free                1      0      0     ",
      "17": "ret                 0      -1     -     "
    },
    "backend": {
      "00": "set                 0      2      0     ",
      "01": "table_open_part     1      0      8     # public.test (primary)",
      "02": "table_readi32       2      1      0     ",
      "03": "push                2      0      0     ",
      "04": "table_readi32       2      1      1     ",
      "05": "push                2      0      0     ",
      "06": "set_add             0      0      0     ",
      "07": "table_next          1      2      0     ",
      "08": "free                1      0      0     ",
      "09": "ret                 0      -1     -     "
    }
  },
  "access": [["public.test", "ro"]]
}]
declare x table (a int, b int); select * into x from test; select * from x
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select * into x from test; select * from x as it
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select data, id into x from test; select * from x
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select data, id into x from test; select * from x as it
[[1, 1], [2, 2], [3, 3]]
# test: select into table (null)
declare x table (a int, b int); select * into x from test; x := null; select x::type
["null"]
# test: select into table (mix)
declare x table (a int, b int); declare a int; select * into x, a from test;
{"msg": "declare x table (a int, b int); declare a int; ❰select❱ ⟵ INTO accept only one table variable"}
declare x table (a int, b int); declare a int; select * into a, x from test;
{"msg": "declare x table (a int, b int); declare a int; ❰select❱ ⟵ INTO accept only one table variable"}
# test: select from var (table)
declare x table (a int, b int); select * into x from test; select * from x as it
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select * into x from test; select it.a, it.b from x as it
[[1, 1], [2, 2], [3, 3]]
drop table test
# test: := if
declare x int := if true then end
{"msg": "declare x int := ❰if❱ ⟵ bad expression"}
# test: := for
declare x int := for i in ([1,2,3]) do end
{"msg": "declare x int := ❰for❱ ⟵ bad expression"}
disconnect S0
close E0
