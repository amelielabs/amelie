open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }]
connect E0 S0 127.0.0.1:3485
# test: declare parsing
declare
{"msg": "declare ⟵ name expected"}
declare 1
{"msg": "declare ❰1❱ ⟵ name expected"}
declare name
{"msg": "declare name ⟵ unrecognized data type"}
# test: declare
declare a int
declare a int;
explain declare a int;
{"msg": "❰explain❱ ⟵ EXPLAIN without command"}
# test: declare begin/end
declare a int; begin; select a; end;
{"msg": "declare a int; begin❰;❱ ⟵ unsupported statement"}
explain begin; declare a int; select a; end;
[{
  "bytecode": {
    "frontend": {
      "00": "dup                 1      0      0     ",
      "01": "content             1      -      -     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
begin; declare a int; select a; end;
[null]
# test: declare default
explain declare a int; select a
[{
  "bytecode": {
    "frontend": {
      "00": "dup                 1      0      0     ",
      "01": "content             1      -      -     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare a int; select a
[null]
explain declare a int; declare b int; select a, b
[{
  "bytecode": {
    "frontend": {
      "00": "set                 2      2      0     ",
      "01": "dup                 3      0      0     ",
      "02": "push                3      0      0     ",
      "03": "dup                 3      1      0     ",
      "04": "push                3      0      0     ",
      "05": "set_add             2      0      0     ",
      "06": "content             2      -      -     ",
      "07": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare a int; declare b int; select a, b
[[null, null]]
declare a int; declare b json; select a::type, b::type
[["null", "null"]]
# test: declare redefine
declare a int; declare a int;
{"msg": "declare a int; declare ❰a❱ ⟵ variable redefined"}
# test: declare null
declare a null;
{"msg": "declare a ❰null❱ ⟵ unrecognized data type"}
# test: := operator parsing
:=
{"msg": ":= ⟵ unexpected statement"}
0 :=
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
0 := 0
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
'x' := 1
{"msg": "'x' ❰:=❱ ⟵ unexpected statement"}
x :=
{"msg": "x := ⟵ bad expression"}
# test: := expr
x := 1
{"msg": "x := 1 ⟵ variable 'x' not found"}
explain x := 1
{"msg": "explain x := 1 ⟵ variable 'x' not found"}
declare x int; x := 1
explain declare x int; x := 1
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: := expr
declare x int; x := 1; select x
[1]
explain declare x int; x := 1; select x
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "dup                 1      0      0     ",
      "04": "content             1      -      -     ",
      "05": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x int; declare y int; x := 1; y := 2; select x + y
[3]
# test: := expr (json)
declare x json; x := {"id": 48}; select x.id
[48]
explain declare x json; x := {"id": 48}; select x.id
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "dup                 1      0      0     ",
      "04": "string              2      7      0     # id",
      "05": "dotjs               3      1      2     ",
      "06": "content             3      -      -     ",
      "07": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: := expr (null)
declare x int; x := null; select x
[null]
explain declare x int; x := null; select x
[{
  "bytecode": {
    "frontend": {
      "00": "null                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "dup                 1      0      0     ",
      "04": "content             1      -      -     ",
      "05": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x int; x := null; select x + 10
[null]
# test: := expr (column shadow)
create table test (id int primary key)
insert into test values (1)
declare id int; id := 1; select * from test where id = id
[1]
declare id int; id := 1; select * from test where test.id = id
[1]
drop table test
# test: insert returning into (1 column)
create table test (id int primary key)
insert into test values (1), (2), (3), (4)
# test: var pushdown
declare x int; x := 1; select * from test where id = x
[1]
explain declare x int; x := 1; select * from test where id = x
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "push_dup            0      0      0     ",
      "04": "union               1      0      0     ",
      "05": "dup                 2      0      0     ",
      "06": "push                2      0      0     ",
      "07": "send_lookup_by      0      -      -     # public.test (last)",
      "08": "union_recv          1      0      0     ",
      "09": "union_set           1      0      -1    ",
      "10": "content             1      -      -     ",
      "11": "ret                 0      0      0     "
    },
    "backend": {
      "00": "set                 1      1      0     ",
      "01": "ref                 2      0      0     ",
      "02": "push                2      0      0     ",
      "03": "table_open_partl    2      0      11    # public.test (primary)",
      "04": "table_readi32       3      2      0     ",
      "05": "ref                 4      0      0     ",
      "06": "equii               5      3      4     ",
      "07": "jntr                11     5      0     ",
      "08": "table_readi32       3      2      0     ",
      "09": "push                3      0      0     ",
      "10": "set_add             1      0      0     ",
      "11": "free                2      0      0     ",
      "12": "result              1      0      0     ",
      "13": "ret                 0      0      0     "
    }
  },
  "access": [["public.test", "ro"]]
}]
# test: := with cte
declare x int; x := with a as (select 1) select * from a; select x
{"msg": "declare x int; x := ❰with❱ ⟵ bad expression"}
# test: := with cte (assign inside)
declare x int; with a as (x := select 1) select * from a; select x
{"msg": "declare x int; with a as (x ❰:=❱ ⟵ unexpected statement"}
drop table test
# test: := ddl
declare x json; x := show all;
{"msg": "declare x json; x := ❰show❱ ⟵ bad expression"}
# test: declare := select expr
declare x int := select 1
{"msg": "declare x int := ❰select❱ ⟵ unexpected subquery"}
explain declare x int := select 1
{"msg": "explain declare x int := ❰select❱ ⟵ unexpected subquery"}
# test: select into (not defined)
select 1 into x; select x
{"msg": "select 1 into x❰;❱ ⟵ variable 'x' not found"}
# test: select into
declare x int; select 1 into x; select x
[1]
# test: select into (redefine)
declare x int; select 1 into x; select 2 into x; select x
[2]
declare x int; x := 1; select 2 into x; select x
[2]
# test: select into (cte)
with a as (select 1 into x) select * from a
{"msg": "with a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
declare x int; with a as (select 1 into x) select * from a
{"msg": "declare x int; with a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
# test: select into (subquery)
declare x int; select (select 1 into x); select x
{"msg": "declare x int; select (select 1 ❰into❱ ⟵ INTO cannot be used inside subquery"}
# test: select into (var)
declare x int; x := select 1 into x; select x
{"msg": "declare x int; x := ❰select❱ ⟵ unexpected subquery"}
# test: insert returning into (1 column)
create table test (id int primary key)
declare x int; insert into test values (1) returning id into x; select x
[1]
# test: insert returning into (2 columns, 1 into)
declare x int; insert into test values (2) returning id, id into x; select x
[2]
# test: insert returning into (2 columns, 2 into)
declare x int; declare y int; insert into test values (3) returning id, id + 10 into x, y; select x, y
[[3, 13]]
# test: insert returning into (2 columns, 2 into rewrite)
declare x int; insert into test values (4) returning id, id + 10 into x, x; select x
[14]
drop table test
# test: select from var
explain declare x json := [1,2,3]; select * from x as it;
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "set                 1      1      0     ",
      "04": "dup                 2      0      0     ",
      "05": "json_open           3      2      10    ",
      "06": "json_read           4      3      0     ",
      "07": "push                4      0      0     ",
      "08": "set_add             1      0      0     ",
      "09": "json_next           3      6      0     ",
      "10": "free                3      0      0     ",
      "11": "free                2      0      0     ",
      "12": "content             1      -      -     ",
      "13": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from x as it;
[1, 2, 3]
explain declare x json := [1,2,3]; select * from (x) as it;
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "free                1      0      0     ",
      "03": "set                 1      1      0     ",
      "04": "dup                 2      0      0     ",
      "05": "json_open           3      2      10    ",
      "06": "json_read           4      3      0     ",
      "07": "push                4      0      0     ",
      "08": "set_add             1      0      0     ",
      "09": "json_next           3      6      0     ",
      "10": "free                3      0      0     ",
      "11": "free                2      0      0     ",
      "12": "content             1      -      -     ",
      "13": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from (x) as it;
[1, 2, 3]
# test: declare table parsing
declare x table
{"msg": "declare x table ⟵ ( expected"}
declare x table 1
{"msg": "declare x table ❰1❱ ⟵ ( expected"}
declare x table (
{"msg": "declare x table ( ⟵ name expected"}
declare x table ()
{"msg": "declare x table (❰)❱ ⟵ name expected"}
declare x table (id
{"msg": "declare x table (id ⟵ unrecognized data type"}
declare x table (id int
{"msg": "declare x table (id int ⟵ ) expected"}
# test: declare table
create table test (id int primary key)
insert into test values (1), (2), (3)
declare x table (id int); select x::type
["null"]
declare x table (id int); select 123 into x; select x
[123]
declare x table (id int); select * into x from test; select x::type
["store"]
declare x table (id int); select * into x from test; select x
[1, 2, 3]
drop table test
# test: select into table (mismatch)
create table test (id int primary key, data int)
insert into test values (1, 1), (2, 2), (3, 3)
declare x table (a int, b int); select id into x from test;
{"msg": "declare x table (a int, b int); ❰select❱ ⟵ variable table columns mismatch"}
# test: select into table
declare x table (a int, b int); select * into x from test; select * from x
{"msg": "declare x table (a int, b int); select * into x from test; select ❰*❱ ⟵ variable 'x' is not a json"}
declare x table (a int, b int); select * into x from test; select * from x _
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select data, id into x from test; select * from x _
[[1, 1], [2, 2], [3, 3]]
# test: select into table (null)
declare x table (a int, b int); select * into x from test; x := null; select x::type
["null"]
# test: select into table (mix)
declare x table (a int, b int); declare a int; select * into x, a from test;
{"msg": "declare x table (a int, b int); declare a int; ❰select❱ ⟵ INTO accept only one table variable"}
declare x table (a int, b int); declare a int; select * into a, x from test;
{"msg": "declare x table (a int, b int); declare a int; ❰select❱ ⟵ INTO accept only one table variable"}
# test: select from var (table)
declare x table (a int, b int); select * into x from test; select * from x as it
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); select * into x from test; select it.a, it.b from x as it
[[1, 1], [2, 2], [3, 3]]
drop table test
# test: := if
declare x int := if true then end
{"msg": "declare x int := ❰if❱ ⟵ bad expression"}
# test: := for
declare x int := for i in ([1,2,3]) do end
{"msg": "declare x int := ❰for❱ ⟵ bad expression"}
disconnect S0
close E0
