open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }]
connect E0 S0 127.0.0.1:3485
# test: declare parsing
declare
{"msg": "declare ⟵ name expected"}
declare 1
{"msg": "declare ❰1❱ ⟵ name expected"}
declare name
{"msg": "declare name ⟵ unrecognized data type"}
# test: declare
declare a int
{"msg": "declare a int ⟵ ; expected"}
declare a int;
explain declare a int;
{"msg": "❰explain❱ ⟵ EXPLAIN without command"}
# test: declare begin/end
declare a int; begin; select a; end;
{"msg": "declare a int; begin❰;❱ ⟵ unsupported statement"}
explain begin; declare a int; select a; end;
[{
  "bytecode": {
    "frontend": {
      "00": "dup                 1      0      0     ",
      "01": "content             1      -      -     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
begin; declare a int; select a; end;
[null]
# test: declare default
explain declare a int; select a
[{
  "bytecode": {
    "frontend": {
      "00": "dup                 1      0      0     ",
      "01": "content             1      -      -     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare a int; select a
[null]
explain declare a int; declare b int; select a, b
[{
  "bytecode": {
    "frontend": {
      "00": "set                 2      2      0     ",
      "01": "dup                 3      0      0     ",
      "02": "push                3      0      0     ",
      "03": "dup                 3      1      0     ",
      "04": "push                3      0      0     ",
      "05": "set_add             2      0      0     ",
      "06": "content             2      -      -     ",
      "07": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare a int; declare b int; select a, b
[[null, null]]
declare a int; declare b json; select a::type, b::type
[["null", "null"]]
# test: declare redefine
declare a int; declare a int;
{"msg": "declare a int; declare ❰a❱ ⟵ variable redefined"}
# test: declare null
declare a null;
{"msg": "declare a ❰null❱ ⟵ unrecognized data type"}
# test: := operator parsing
:=
{"msg": ":= ⟵ unexpected statement"}
0 :=
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
0 := 0
{"msg": "0 ❰:=❱ ⟵ unexpected statement"}
'x' := 1
{"msg": "'x' ❰:=❱ ⟵ unexpected statement"}
x :=
{"msg": "❰x❱ ⟵ variable not found"}
# test: := expr
x := 1
{"msg": "❰x❱ ⟵ variable not found"}
explain x := 1
{"msg": "explain ❰x❱ ⟵ variable not found"}
declare x int; x := 1
explain declare x int; x := 1
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: := select expr
declare x int; x := select 1
explain declare x int; x := select 1
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: := select var
declare x int; x := 1; select x
[1]
explain declare x int; x := 1; select x
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "dup                 1      0      0     ",
      "03": "content             1      -      -     ",
      "04": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x int; declare y int; x := 1; y := 2; select x + y
[3]
# test: := select var (json)
declare x json; x := {"id": 48}; select x.id
[48]
explain declare x json; x := {"id": 48}; select x.id
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "dup                 1      0      0     ",
      "03": "string              2      7      0     # id",
      "04": "dotjs               3      1      2     ",
      "05": "content             3      -      -     ",
      "06": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: := select var (null)
declare x int; x := null; select x
[null]
explain declare x int; x := null; select x
[{
  "bytecode": {
    "frontend": {
      "00": "null                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "dup                 1      0      0     ",
      "03": "content             1      -      -     ",
      "04": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x int; x := null; select x + 10
[null]
# test: := select var (1 column)
declare x int; x := select 1; select x
[1]
# test: := select var (n columns)
declare x int; x := select 1, 2; select x
{"msg": "declare x int; x := select 1, 2; select x ⟵ statement must return only one column to be assigned"}
# test: := select var (column shadow)
create table test (id int primary key)
insert into test values (1)
declare id int; id := 1; select * from test where id = id
[1]
declare id int; id := 1; select * from test where test.id = id
[1]
drop table test
# test: := insert returning (1 column)
create table test (id int primary key)
declare x int; x := insert into test values (1) returning id; select x
[1]
# test: := insert returning (n columns)
declare x int; x := insert into test values (2) returning id, id; select x
{"msg": "declare x int; x := insert into test values (2) returning id, id; select x ⟵ statement must return only one column to be assigned"}
# test: := pushdown
declare x int; x := 1; select * from test where id = x
[1]
explain declare x int; x := 1; select * from test where id = x
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "push_dup            0      0      0     ",
      "03": "union               1      0      0     ",
      "04": "dup                 2      0      0     ",
      "05": "push                2      0      0     ",
      "06": "send_lookup_by      0      -      -     # public.test (last)",
      "07": "union_recv          1      0      0     ",
      "08": "union_set           1      0      -1    ",
      "09": "content             1      -      -     ",
      "10": "ret                 0      0      0     "
    },
    "backend": {
      "00": "set                 1      1      0     ",
      "01": "ref                 2      0      0     ",
      "02": "push                2      0      0     ",
      "03": "table_open_partl    2      0      11    # public.test (primary)",
      "04": "table_readi32       3      2      0     ",
      "05": "ref                 4      0      0     ",
      "06": "equii               5      3      4     ",
      "07": "jntr                11     5      0     ",
      "08": "table_readi32       3      2      0     ",
      "09": "push                3      0      0     ",
      "10": "set_add             1      0      0     ",
      "11": "free                2      0      0     ",
      "12": "result              1      0      0     ",
      "13": "ret                 0      0      0     "
    }
  },
  "access": [["public.test", "ro"]]
}]
# test: := with cte
declare x int; x := with a as (select 1) select * from a; select x
[1]
# test: := with cte (assign inside)
declare x int; with a as (x := select 1) select * from a; select x
{"msg": "declare x int; with a as (x ❰:=❱ ⟵ unexpected statement"}
drop table test
# test: := ddl
declare x json; x := show all;
{"msg": "declare x json; x := show all❰;❱ ⟵ := cannot be used with utility statements"}
# test: declare := select expr
declare x int := select 1
explain declare x int := select 1
[{
  "bytecode": {
    "frontend": {
      "00": "int                 1      -      0     # 1",
      "01": "assign              0      1      0     ",
      "02": "ret                 0      0      0     "
    }
  },
  "access": []
}]
# test: select into (not defined)
select 1 into x; select x
{"msg": "select 1 into ❰x❱ ⟵ variable not found"}
# test: select into
declare x int; select 1 into x; select x
[1]
# test: select into (redefine)
declare x int; select 1 into x; select 2 into x; select x
[2]
declare x int; x := 1; select 2 into x; select x
[2]
# test: select into (cte)
with a as (select 1 into x) select * from a
{"msg": "with a as (select 1 into ❰x❱ ⟵ INTO cannot be used with CTE"}
declare x int; with a as (select 1 into x) select * from a
{"msg": "declare x int; with a as (select 1 into ❰x❱ ⟵ INTO cannot be used with CTE"}
# test: select into (subquery)
declare x int; select (select 1 into x); select x
{"msg": "declare x int; select (select 1 into ❰x❱ ⟵ INTO cannot be used inside subquery"}
# test: select into (var)
declare x int; x := select 1 into x; select x
{"msg": "declare x int; x := select 1 into ❰x❱ ⟵ INTO cannot be used with := operator"}
# test: returning into
create table test (id int primary key)
declare x int; insert into test values (1) returning id into x; select x
[1]
# test: returning into (var)
declare x int; x := insert into test values (1) returning id into x; select x
{"msg": "declare x int; x := insert into test values (1) returning id into ❰x❱ ⟵ INTO cannot be used with := operator"}
declare x string; x := insert into test values (1) returning id into x; select x
{"msg": "declare x string; x := insert into test values (1) returning id into ❰x❱ ⟵ INTO cannot be used with := operator"}
# test: returning into (cte)
declare x int; with a as (insert into test values (1) returning id into x) select * from a
{"msg": "declare x int; with a as (insert into test values (1) returning id into ❰x❱ ⟵ INTO cannot be used with CTE"}
drop table test
# test: select from var
explain declare x json := [1,2,3]; select * from x as it;
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "set                 1      1      0     ",
      "03": "dup                 2      0      0     ",
      "04": "json_open           3      2      9     ",
      "05": "json_read           4      3      0     ",
      "06": "push                4      0      0     ",
      "07": "set_add             1      0      0     ",
      "08": "json_next           3      5      0     ",
      "09": "free                3      0      0     ",
      "10": "free                2      0      0     ",
      "11": "content             1      -      -     ",
      "12": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from x as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from x as it;
[1, 2, 3]
explain declare x json := [1,2,3]; select * from (x) as it;
[{
  "bytecode": {
    "frontend": {
      "00": "json                1      0      0     ",
      "01": "assign              0      1      0     ",
      "02": "set                 1      1      0     ",
      "03": "dup                 2      0      0     ",
      "04": "json_open           3      2      9     ",
      "05": "json_read           4      3      0     ",
      "06": "push                4      0      0     ",
      "07": "set_add             1      0      0     ",
      "08": "json_next           3      5      0     ",
      "09": "free                3      0      0     ",
      "10": "free                2      0      0     ",
      "11": "content             1      -      -     ",
      "12": "ret                 0      0      0     "
    }
  },
  "access": []
}]
declare x json := [1,2,3]; select * from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it from (x) as it;
[1, 2, 3]
declare x json := [1,2,3]; select it.it from (x) as it;
[1, 2, 3]
# test: declare table parsing
declare x table
{"msg": "declare x table ⟵ ( expected"}
declare x table 1
{"msg": "declare x table ❰1❱ ⟵ ( expected"}
declare x table (
{"msg": "declare x table ( ⟵ name expected"}
declare x table ()
{"msg": "declare x table (❰)❱ ⟵ name expected"}
declare x table (id
{"msg": "declare x table (id ⟵ unrecognized data type"}
declare x table (id int
{"msg": "declare x table (id int ⟵ ) expected"}
# test: declare table
create table test (id int primary key)
insert into test values (1), (2), (3)
declare x table (id int); select x::type
["null"]
declare x table (id int); x := select * from test; select x::type
["store"]
declare x table (id int); x := select * from test; select x
[1, 2, 3]
drop table test
# test: := table (mismatch)
create table test (id int primary key, data int)
insert into test values (1, 1), (2, 2), (3, 3)
declare x table (a int, b int); x := select id from test;
{"msg": "declare x table (a int, b int); x := ❰select❱ ⟵ variable table columns mismatch"}
# test: := table
declare x table (a int, b int); x := select * from test;
declare x table (a int, b int); x := select data, id from test;
# test: := table (null)
declare x table (a int, b int); x := select * from test; x := null; select x::type
["null"]
# test: select from var (table)
declare x table (a int, b int); x := select * from test; select * from x as it
[[1, 1], [2, 2], [3, 3]]
declare x table (a int, b int); x := select * from test; select it.a, it.b from x as it
[[1, 1], [2, 2], [3, 3]]
drop table test
disconnect S0
close E0
