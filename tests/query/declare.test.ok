open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }];
connect E0 S0 127.0.0.1:3485;
# test: declare parsing
declare;
{"msg": "declare❰;❱ ⟵ name expected"}
declare 1;
{"msg": "declare ❰1❱ ⟵ name expected"}
declare name;
{"msg": "declare name❰;❱ ⟵ unrecognized data type"}
# test: declare
declare a int;
declare a int;
explain declare a int;
{"msg": "❰explain❱ ⟵ EXPLAIN without command"}
# test: declare begin/end
explain begin;
	declare a int;
	select a;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "var                 0      0      0     ",
    "02": "ret                 0      0      -     "
  },
  "access": []
}]
begin;
	declare a int;
	select a;
end;
[null]
# test: declare default
explain begin
	declare a int;
	select a;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "var                 0      0      0     ",
    "02": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare a int;
	select a;
end;
[null]
explain begin
	declare a int;
	declare b int;
	select a, b;
end;
[{
  "main": {
    "00": "push_nulls          2      0      0     ",
    "01": "set                 0      2      0     ",
    "02": "var                 1      0      0     ",
    "03": "push                1      0      0     ",
    "04": "var                 1      1      0     ",
    "05": "push                1      0      0     ",
    "06": "set_add             0      0      0     ",
    "07": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare a int;
	declare b int;
	select a, b;
end;
[[null, null]]
begin
	declare a int;
	declare b json;
	select a::type, b::type;
end;
[["null", "null"]]
# test: declare redefine
begin
	declare a int;
	declare a int;
end;
{"msg": "begin\n\tdeclare a int;\n\tdeclare ❰a❱ ⟵ variable redefined"}
# test: declare null
declare a null;
{"msg": "declare a ❰null❱ ⟵ unrecognized data type"}
# test: := operator parsing
:=;
{"msg": "❰:=❱ ⟵ unexpected statement"}
0 :=;
{"msg": "❰0❱ ⟵ unexpected statement"}
0 := 0;
{"msg": "❰0❱ ⟵ unexpected statement"}
'x' := 1;
{"msg": "❰'x'❱ ⟵ unexpected statement"}
x :=;
{"msg": "x :=❰;❱ ⟵ bad expression"}
# test: := expr
x := 1;
{"msg": "x := 1❰;❱ ⟵ variable 'x' not found"}
explain x := 1;
{"msg": "explain x := 1❰;❱ ⟵ variable 'x' not found"}
begin
	declare x int;
	x := 1;
end;
explain begin
	declare x int;
	x := 1;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "int                 0      -      0     # 1",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "ret                 -1     0      -     "
  },
  "access": []
}]
# test: := expr
begin
	declare x int;
	x := 1;
	select x;
end;
[1]
explain begin
	declare x int;
	x := 1;
	select x;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "int                 0      -      0     # 1",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare x int;
	declare y int;
	x := 1;
	y := 2;
	select x + y;
end;
[3]
# test: := expr (json)
begin
	declare x json;
	x := {"id": 48};
	select x.id;
end;
[48]
explain begin
	declare x json;
	x := {"id": 48};
	select x.id;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "json                0      0      0     ",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "string              1      7      0     # id",
    "06": "dotjs               2      0      1     ",
    "07": "ret                 2      0      -     "
  },
  "access": []
}]
# test: := expr (null)
begin
	declare x int;
	x := null;
	select x;
end;
[null]
explain begin
	declare x int;
	x := null;
	select x;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "null                0      0      0     ",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare x int;
	x := null;
	select x + 10;
end;
[null]
# test: := expr (column shadow)
create table test (id int primary key);
insert into test values (1);
explain begin
	declare id int;
	id := 1;
	select * from test where id = id;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "int                 0      -      0     # 1",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "push_ref            0      0      0     ",
    "06": "var                 0      0      0     ",
    "07": "push_ref            0      0      0     ",
    "08": "union               0      0      0     ",
    "09": "send_all            0      -      0     # public.test (last)",
    "10": "union_recv          0      0      0     ",
    "11": "union_set           0      0      -1    ",
    "12": "ret                 0      0      -     "
  },
  "pushdown": {
    "00": "set                 0      1      0     ",
    "01": "table_open_part     1      0      10    # public.test (primary)",
    "02": "ref                 2      0      0     ",
    "03": "ref                 3      1      0     ",
    "04": "equii               4      2      3     ",
    "05": "jntr                9      4      0     ",
    "06": "table_readi32       2      1      0     ",
    "07": "push                2      0      0     ",
    "08": "set_add             0      0      0     ",
    "09": "table_next          1      2      0     ",
    "10": "free                1      0      0     ",
    "11": "ret                 0      0      -     "
  },
  "access": [["public.test", "ro"]]
}]
begin
	declare id int;
	id := 1;
	select * from test where id = id;
end;
[1]
explain begin
	declare id int;
	id := 1;
	select * from test where test.id = id;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "int                 0      -      0     # 1",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "push_ref            0      0      0     ",
    "06": "union               0      0      0     ",
    "07": "var                 1      0      0     ",
    "08": "push                1      0      0     ",
    "09": "send_lookup_by      0      -      -     # public.test (last)",
    "10": "union_recv          0      0      0     ",
    "11": "union_set           0      0      -1    ",
    "12": "ret                 0      0      -     "
  },
  "pushdown": {
    "00": "set                 0      1      0     ",
    "01": "ref                 1      0      0     ",
    "02": "push                1      0      0     ",
    "03": "table_open_partl    1      0      11    # public.test (primary)",
    "04": "table_readi32       2      1      0     ",
    "05": "ref                 3      0      0     ",
    "06": "equii               4      2      3     ",
    "07": "jntr                11     4      0     ",
    "08": "table_readi32       2      1      0     ",
    "09": "push                2      0      0     ",
    "10": "set_add             0      0      0     ",
    "11": "free                1      0      0     ",
    "12": "ret                 0      0      -     "
  },
  "access": [["public.test", "ro"]]
}]
begin
	declare id int; id := 1;
	select * from test where test.id = id;
end;
[1]
drop table test;
# test: insert returning into (1 column)
create table test (id int primary key);
insert into test values (1), (2), (3), (4);
# test: var pushdown
begin
	declare x int;
	x := 1;
	select * from test where id = x;
	end;
[1]
explain begin
	declare x int;
	x := 1;
	select * from test where id = x;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "int                 0      -      0     # 1",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "var                 0      0      0     ",
    "05": "push_ref            0      0      0     ",
    "06": "union               0      0      0     ",
    "07": "var                 1      0      0     ",
    "08": "push                1      0      0     ",
    "09": "send_lookup_by      0      -      -     # public.test (last)",
    "10": "union_recv          0      0      0     ",
    "11": "union_set           0      0      -1    ",
    "12": "ret                 0      0      -     "
  },
  "pushdown": {
    "00": "set                 0      1      0     ",
    "01": "ref                 1      0      0     ",
    "02": "push                1      0      0     ",
    "03": "table_open_partl    1      0      11    # public.test (primary)",
    "04": "table_readi32       2      1      0     ",
    "05": "ref                 3      0      0     ",
    "06": "equii               4      2      3     ",
    "07": "jntr                11     4      0     ",
    "08": "table_readi32       2      1      0     ",
    "09": "push                2      0      0     ",
    "10": "set_add             0      0      0     ",
    "11": "free                1      0      0     ",
    "12": "ret                 0      0      -     "
  },
  "access": [["public.test", "ro"]]
}]
# test: := with cte
begin
	declare x int;
	x := with a as (select 1) select * from a;
	select x;
end;
{"msg": "begin\n\tdeclare x int;\n\tx := ❰with❱ ⟵ bad expression"}
# test: := with cte (assign inside)
begin
	declare x int;
	with a as (x := select 1) select * from a;
	select x;
end;
{"msg": "begin\n\tdeclare x int;\n\twith a as (❰x❱ ⟵ unexpected statement"}
drop table test;
# test: := ddl
begin
	declare x json;
	x := show all;
end;
{"msg": "begin\n\tdeclare x json;\n\tx := ❰show❱ ⟵ bad expression"}
# test: declare := select expr
begin
	declare x int := select 1;
end;
{"msg": "begin\n\tdeclare x int := ❰select❱ ⟵ unexpected subquery"}
explain begin
	declare x int := select 1;
end;
{"msg": "explain begin\n\tdeclare x int := ❰select❱ ⟵ unexpected subquery"}
# test: select into (not defined)
begin
	select 1 into x;
	select x;
end;
{"msg": "begin\n\tselect 1 into x❰;❱ ⟵ variable 'x' not found"}
# test: select into
begin
	declare x int;
	select 1 into x;
	select x;
end;
[1]
# test: select into (redefine)
begin
	declare x int;
	select 1 into x;
	select 2 into x;
	select x;
end;
[2]
begin
	declare x int;
	x := 1;
	select 2 into x;
	select x;
end;
[2]
# test: select into (cte)
begin
	with a as (select 1 into x) select * from a;
end;
{"msg": "begin\n\twith a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
begin
	declare x int;
	with a as (select 1 into x) select * from a;
end;
{"msg": "begin\n\tdeclare x int;\n\twith a as (select 1 ❰into❱ ⟵ INTO cannot be used with CTE"}
# test: select into (subquery)
begin
	declare x int;
	select (select 1 into x);
	select x;
end;
{"msg": "begin\n\tdeclare x int;\n\tselect (select 1 ❰into❱ ⟵ INTO cannot be used inside subquery"}
# test: select into (var)
begin
	declare x int;
	x := select 1 into x;
	select x;
end;
{"msg": "begin\n\tdeclare x int;\n\tx := ❰select❱ ⟵ unexpected subquery"}
# test: insert returning into (1 column)
create table test (id int primary key);
begin
	declare x int;
	insert into test values (1) returning id into x;
	select x;
end;
[1]
# test: insert returning into (2 columns, 1 into)
begin
	declare x int;
	insert into test values (2) returning id, id into x;
	select x;
end;
[2]
# test: insert returning into (2 columns, 2 into)
begin
	declare x int;
	declare y int;
	insert into test values (3) returning id, id + 10 into x, y;
	select x, y;
end;
[[3, 13]]
# test: insert returning into (2 columns, 2 into rewrite)
begin
	declare x int;
	insert into test values (4) returning id, id + 10 into x, x;
	select x;
end;
[14]
drop table test;
# test: select from var
explain begin
	declare x json := [1,2,3];
	select * from x as it;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "json                0      0      0     ",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "set                 0      1      0     ",
    "05": "var                 1      0      0     ",
    "06": "json_open           2      1      11    ",
    "07": "json_read           3      2      0     ",
    "08": "push                3      0      0     ",
    "09": "set_add             0      0      0     ",
    "10": "json_next           2      7      0     ",
    "11": "free                2      0      0     ",
    "12": "free                1      0      0     ",
    "13": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare x json := [1,2,3];
	select * from x as it;
end;
[1, 2, 3]
begin
	declare x json := [1,2,3];
	select it from x as it;
end;
[1, 2, 3]
begin
	declare x json := [1,2,3];
	select it.it from x as it;
end;
[1, 2, 3]
explain begin
	declare x json := [1,2,3];
	select * from (x) as it;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "json                0      0      0     ",
    "02": "var_set             0      0      0     ",
    "03": "free                0      0      0     ",
    "04": "set                 0      1      0     ",
    "05": "var                 1      0      0     ",
    "06": "json_open           2      1      11    ",
    "07": "json_read           3      2      0     ",
    "08": "push                3      0      0     ",
    "09": "set_add             0      0      0     ",
    "10": "json_next           2      7      0     ",
    "11": "free                2      0      0     ",
    "12": "free                1      0      0     ",
    "13": "ret                 0      0      -     "
  },
  "access": []
}]
begin
	declare x json := [1,2,3];
	select * from (x) as it;
end;
[1, 2, 3]
begin
	declare x json := [1,2,3];
	select it from (x) as it;
end;
[1, 2, 3]
begin
	declare x json := [1,2,3];
	select it.it from (x) as it;
end;
[1, 2, 3]
# test: declare table parsing
declare x table;
{"msg": "declare x table❰;❱ ⟵ ( expected"}
declare x table 1;
{"msg": "declare x table ❰1❱ ⟵ ( expected"}
declare x table (;
{"msg": "declare x table (❰;❱ ⟵ name expected"}
declare x table ();
{"msg": "declare x table (❰)❱ ⟵ name expected"}
declare x table (id;
{"msg": "declare x table (id❰;❱ ⟵ unrecognized data type"}
declare x table (id int;
{"msg": "declare x table (id int❰;❱ ⟵ ) expected"}
# test: declare table
create table test (id int primary key);
insert into test values (1), (2), (3);
begin
	declare x table (id int);
	select x::type;
end;
["null"]
begin
	declare x table (id int);
	select 123 into x;
	select x;
end;
[123]
begin
	declare x table (id int);
	select * into x from test;
	select x::type;
end;
["store"]
begin
	declare x table (id int);
	select * into x from test;
	select x;
end;
[1, 2, 3]
drop table test;
# test: select into table (mismatch)
create table test (id int primary key, data int);
insert into test values (1, 1), (2, 2), (3, 3);
begin
	declare x table (a int, b int);
	select id into x from test;
end;
{"msg": "begin\n\tdeclare x table (a int, b int);\n\t❰select❱ ⟵ variable table columns mismatch"}
# test: select into table
explain begin
	declare x table (a int, b int);
	select * into x from test;
	select * from x;
end;
[{
  "main": {
    "00": "push_nulls          1      0      0     ",
    "01": "union               0      0      0     ",
    "02": "send_all            0      -      0     # public.test (last)",
    "03": "union_recv          0      0      0     ",
    "04": "union_set           0      0      -1    ",
    "05": "var_mov             0      0      0     ",
    "06": "set                 0      2      0     ",
    "07": "var                 1      0      0     ",
    "08": "store_open          2      1      15    ",
    "09": "store_read          3      2      0     ",
    "10": "push                3      0      0     ",
    "11": "store_read          3      2      1     ",
    "12": "push                3      0      0     ",
    "13": "set_add             0      0      0     ",
    "14": "store_next          2      9      0     ",
    "15": "free                2      0      0     ",
    "16": "free                1      0      0     ",
    "17": "ret                 0      0      -     "
  },
  "pushdown": {
    "00": "set                 0      2      0     ",
    "01": "table_open_part     1      0      8     # public.test (primary)",
    "02": "table_readi32       2      1      0     ",
    "03": "push                2      0      0     ",
    "04": "table_readi32       2      1      1     ",
    "05": "push                2      0      0     ",
    "06": "set_add             0      0      0     ",
    "07": "table_next          1      2      0     ",
    "08": "free                1      0      0     ",
    "09": "ret                 0      0      -     "
  },
  "access": [["public.test", "ro"]]
}]
begin
	declare x table (a int, b int);
	select * into x from test;
	select * from x;
end;
[[1, 1], [2, 2], [3, 3]]
begin
	declare x table (a int, b int);
	select * into x from test;
	select * from x as it;
end;
[[1, 1], [2, 2], [3, 3]]
begin
	declare x table (a int, b int);
	select data, id into x from test;
	select * from x;
end;
[[1, 1], [2, 2], [3, 3]]
begin
	declare x table (a int, b int);
	select data, id into x from test;
	select * from x as it;
end;
[[1, 1], [2, 2], [3, 3]]
# test: select into table (null)
begin
	declare x table (a int, b int);
	select * into x from test;
	x := null;
	select x::type;
end;
["null"]
# test: select into table (mix)
begin
	declare x table (a int, b int);
	declare a int;
	select * into x, a from test;
end;
{"msg": "begin\n\tdeclare x table (a int, b int);\n\tdeclare a int;\n\t❰select❱ ⟵ INTO accept only one table variable"}
begin
	declare x table (a int, b int);
	declare a int;
	select * into a, x from test;
end;
{"msg": "begin\n\tdeclare x table (a int, b int);\n\tdeclare a int;\n\t❰select❱ ⟵ INTO accept only one table variable"}
# test: select from var (table)
begin
	declare x table (a int, b int);
	select * into x from test;
	select * from x as it;
end;
[[1, 1], [2, 2], [3, 3]]
begin
	declare x table (a int, b int);
	select * into x from test;
	select it.a, it.b from x as it;
end;
[[1, 1], [2, 2], [3, 3]]
drop table test;
# test: := if
begin
	declare x int := if true then end;
end;
{"msg": "begin\n\tdeclare x int := ❰if❱ ⟵ bad expression"}
# test: := for
begin
	declare x int := for i in ([1,2,3]) do end;
end;
{"msg": "begin\n\tdeclare x int := ❰for❱ ⟵ bad expression"}
disconnect S0;
close E0;
