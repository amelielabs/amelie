open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }], "shards": 2
connect E0 S0 localhost:3485
# test: lambda parsing
select =>
{"code": 1, "msg": "bad expression"}
select 1 =>
{"code": 1, "msg": "unknown command"}
select name =>
{"code": 1, "msg": "bad expression"}
select name => true
{"code": 1, "msg": "no targets to use with GROUP BY or aggregates"}
# test: lambda (init)
select n => true from []
[null]
select n => true from [1]
[true]
select n => * from [1,2,3]
[3]
# test: lambda (state access)
explain select n => n from [1,2,3]
"
bytecode [coordinator]
--------
 0                 set        0      0      0
 1               group        1      0      0
 2           group_add        1      5      0
 3                null        2      0      0
 4                push        2      0      0
 5         group_write        1      0      0
 6                 int        2      1      0
 7                push        2      0      0
 8                 int        2      2      0
 9                push        2      0      0
10                 int        2      3      0
11                push        2      0      0
12               array        2      3      0
13    cursor_open_expr        0      2     15
14                 jmp       19      0      0
15           group_get        3      1      0
16                push        3      0      0
17         group_write        1      0      0
18         cursor_next        0     15      0
19        cursor_close        0      0      0
20    cursor_open_expr        1      1     22
21                 jmp       25      0      0
22     group_read_aggr        2      1      0
23             set_add        0      2      0
24         cursor_next        1     22      0
25        cursor_close        1      0      0
26             cte_set        0      0      0
27                body        0      0      0
28                 ret        0      0      0

"
select n => n from [1,2,3]
[null]
select n => n::append(*) from [1,2,3]
[[1, 2, 3]]
select n => n::append(*)::append(n) from [1,2,3]
[[1, null, 2, [1, null], 3, [1, null, 2, [1, null]]]]
select n => n::append(*)::append(n::string) from [1,2,3]
[[1, "null", 2, "[1, "null"]", 3, "[1, "null", 2, "[1, "null"]"]"]]
select * from (select n => n::append(*) from [1,2,3])
[[1, 2, 3]]
select obj => obj::set(*, [*]) from ["a", "b", "c"]
[{
  "a": ["a"],
  "b": ["b"],
  "c": ["c"]
}]
select obj => obj::set("key_" || *::string, *) from [1,2,3]
[{
  "key_1": 1,
  "key_2": 2,
  "key_3": 3
}]
# test: lambda (crosss state access)
select i => i::append(*), j => j::append(i) from [1,2,3]
[[[1, 2, 3], [null, [1], [1, 2]]]]
# test: lambda (label)
select (n => n::append(*)) as N from [1,2,3]
[[1, 2, 3]]
# test: lambda (group by)
select *, n => n::append(*) from [1,2,2,3] group by *
[[1, [1]], [2, [2, 2]], [3, [3]]]
# test: lambda (reference table)
create table test (id int primary key) reference
insert into test 1,2,3,4,5
select n => n::append(id) from test
[[1, 2, 3, 4, 5]]
drop table test
create table test (id int primary key, data int) reference
insert into test values (0, 0)
insert into test values (1, 1)
insert into test values (2, 2)
insert into test values (3, 1)
insert into test values (4, 3)
select n => n::append(data) from test
[[0, 1, 2, 1, 3]]
select data, n => n::append(id) from test group by data
[[0, [0]], [1, [1, 3]], [2, [2]], [3, [4]]]
drop table test
# test: lambda (distributed table)
create table test (id int primary key)
insert into test 1,2,3,4,5
select n => n::append(id) from test
{"code": 1, "msg": "operation not supported"}
explain select n => n::append(id) from test
"
bytecode [coordinator]
--------
 0            send_all        0      0      0
 1                recv        0      0      0
 2    group_merge_recv        0      0      0
 3                 set        1      0      0
 4    cursor_open_expr        1      0      6
 5                 jmp        9      0      0
 6     group_read_aggr        2      1      0
 7             set_add        1      2      0
 8         cursor_next        1      6      0
 9        cursor_close        1      0      0
10             cte_set        0      1      0
11                body        0      0      0
12                 ret        0      0      0


bytecode [node]
--------
 0               group        0      0      0
 1           group_add        0      5      0
 2                null        1      0      0
 3                push        1      0      0
 4         group_write        0      0      0
 5             int_min        1      0      0
 6                push        1      0      0
 7         cursor_open        0      0      9      # public.test (primary)
 8                 jmp       17      0      0
 9           group_get        1      0      0
10                push        1      0      0
11          cursor_idx        1      0      0
12                push        1      0      0
13                call        1      -      2      # public.append()
14                push        1      0      0
15         group_write        0      0      0
16         cursor_next        0      9      0
17        cursor_close        0      0      0
18              result        0      0      0
19                 ret        0      0      0

"
drop table test
disconnect S0
close E0
