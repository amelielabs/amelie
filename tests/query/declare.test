#

open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }]
connect E0 S0 127.0.0.1:3485

# test: declare parsing
declare
declare 1
declare name

# test: declare
declare a int
declare a int;
explain declare a int;

# test: declare begin/end
declare a int; begin; select a; end;

explain begin; declare a int; select a; end;
begin; declare a int; select a; end;

# test: declare default
explain declare a int; select a
declare a int; select a

explain declare a int; declare b int; select a, b
declare a int; declare b int; select a, b
declare a int; declare b json; select a::type, b::type

# test: declare redefine
declare a int; declare a int;

# test: declare null
declare a null;

# test: := operator parsing
:=
0 :=
0 := 0
'x' := 1
x :=

# test: := expr
x := 1
explain x := 1

declare x int; x := 1
explain declare x int; x := 1

# test: := expr
declare x int; x := 1; select x
explain declare x int; x := 1; select x
declare x int; declare y int; x := 1; y := 2; select x + y

# test: := expr (json)
declare x json; x := {"id": 48}; select x.id
explain declare x json; x := {"id": 48}; select x.id

# test: := expr (null)
declare x int; x := null; select x
explain declare x int; x := null; select x
declare x int; x := null; select x + 10

# test: := expr (column shadow)
create table test (id int primary key)
insert into test values (1)
# this compares two vars
declare id int; id := 1; select * from test where id = id
declare id int; id := 1; select * from test where test.id = id
drop table test

# test: insert returning into (1 column)
create table test (id int primary key)
insert into test values (1), (2), (3), (4)

# test: var pushdown
declare x int; x := 1; select * from test where id = x
explain declare x int; x := 1; select * from test where id = x

# test: := with cte
declare x int; x := with a as (select 1) select * from a; select x

# test: := with cte (assign inside)
declare x int; with a as (x := select 1) select * from a; select x
drop table test

# test: := ddl
declare x json; x := show all;

# test: declare := select expr
declare x int := select 1
explain declare x int := select 1

# test: select into (not defined)
select 1 into x; select x

# test: select into
declare x int; select 1 into x; select x

# test: select into (redefine)
declare x int; select 1 into x; select 2 into x; select x
declare x int; x := 1; select 2 into x; select x

# test: select into (cte)
with a as (select 1 into x) select * from a
declare x int; with a as (select 1 into x) select * from a

# test: select into (subquery)
declare x int; select (select 1 into x); select x

# test: select into (var)
declare x int; x := select 1 into x; select x

# test: insert returning into (1 column)
create table test (id int primary key)
declare x int; insert into test values (1) returning id into x; select x

# test: insert returning into (2 columns, 1 into)
declare x int; insert into test values (2) returning id, id into x; select x

# test: insert returning into (2 columns, 2 into)
declare x int; declare y int; insert into test values (3) returning id, id + 10 into x, y; select x, y

# test: insert returning into (2 columns, 2 into rewrite)
declare x int; insert into test values (4) returning id, id + 10 into x, x; select x

drop table test

# test: select from var
explain declare x json := [1,2,3]; select * from x as it;
declare x json := [1,2,3]; select * from x as it;
declare x json := [1,2,3]; select it from x as it;
declare x json := [1,2,3]; select it.it from x as it;

explain declare x json := [1,2,3]; select * from (x) as it;
declare x json := [1,2,3]; select * from (x) as it;
declare x json := [1,2,3]; select it from (x) as it;
declare x json := [1,2,3]; select it.it from (x) as it;

# test: declare table parsing
declare x table
declare x table 1
declare x table (
declare x table ()
declare x table (id
declare x table (id int

# test: declare table
create table test (id int primary key)
insert into test values (1), (2), (3)

declare x table (id int); select x::type
declare x table (id int); select 123 into x; select x
declare x table (id int); select * into x from test; select x::type
declare x table (id int); select * into x from test; select x
drop table test

# test: select into table (mismatch)
create table test (id int primary key, data int)
insert into test values (1, 1), (2, 2), (3, 3)

declare x table (a int, b int); select id into x from test;

# test: select into table
explain declare x table (a int, b int); select * into x from test; select * from x
declare x table (a int, b int); select * into x from test; select * from x
declare x table (a int, b int); select * into x from test; select * from x as it

declare x table (a int, b int); select data, id into x from test; select * from x
declare x table (a int, b int); select data, id into x from test; select * from x as it

# test: select into table (null)
declare x table (a int, b int); select * into x from test; x := null; select x::type

# test: select into table (mix)
declare x table (a int, b int); declare a int; select * into x, a from test;
declare x table (a int, b int); declare a int; select * into a, x from test;

# test: select from var (table)
declare x table (a int, b int); select * into x from test; select * from x as it
declare x table (a int, b int); select * into x from test; select it.a, it.b from x as it
drop table test

# test: := if
declare x int := if true then end

# test: := for
declare x int := for i in ([1,2,3]) do end

disconnect S0
close E0
