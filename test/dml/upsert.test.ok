env_open E0
connect E0 S0
connect: on_connect
# test: on conflict parsing
create table test (id int primary key, data int)
insert into test values(1, 0) 123
query: on_error
{"code": 1, "msg": "unexpected clause at the end of command"}
insert into test values(1, 0) ON
query: on_error
{"code": 1, "msg": "INSERT VALUES ON <CONFLICT> expected"}
insert into test values(1, 0) ON 123
query: on_error
{"code": 1, "msg": "INSERT VALUES ON <CONFLICT> expected"}
insert into test values(1, 0) on conflict
query: on_error
{"code": 1, "msg": "INSERT VALUES ON CONFLICT <DO> expected"}
insert into test values(1, 0) on conflict 123
query: on_error
{"code": 1, "msg": "INSERT VALUES ON CONFLICT <DO> expected"}
insert into test values(1, 0) on conflict do
query: on_error
{"code": 1, "msg": "INSERT VALUES ON CONFLICT DO <REPLACE | NOTHING | UPDATE> expected"}
insert into test values(1, 0) on conflict do 123
query: on_error
{"code": 1, "msg": "INSERT VALUES ON CONFLICT DO <REPLACE | NOTHING | UPDATE> expected"}
insert into test values(1, 0) on conflict do update
query: on_error
{"code": 1, "msg": "UPDATE <SET> expected"}
insert into test values(1, 0) on conflict do update set
query: on_error
{"code": 1, "msg": "UPDATE name SET <path> expected"}
insert into test values(1, 0) on conflict do update set 123
query: on_error
{"code": 1, "msg": "UPDATE name SET <path> expected"}
insert into test values(1, 0) on conflict do update set path
query: on_error
{"code": 1, "msg": "UPDATE name SET path <=> expected"}
insert into test values(1, 0) on conflict do update set path =
query: on_error
{"code": 1, "msg": "bad expression"}
# test: on conflict do replace
insert into test values(1, 0)
insert into test values(1, 0)
query: on_error
{"code": 1, "msg": "unique key constraint violation"}
insert into test values(1, null) on conflict do replace
insert into test values(1, null) on conflict do replace
select * from test
[1, null]
drop table test
# test: on conflict do nothing
create table test (id int primary key, data int)
explain insert into test values(1, 0) on conflict do nothing
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp        3      0      0
 2             jmp_pop        0      0      0
 3              upsert        0      0      3
 4        cursor_close        0      0      0
 5                 ret        0      0      0

"
insert into test values(1, 0) on conflict do nothing
insert into test values(1, 0) on conflict do nothing
insert into test values(1, 0) on conflict do nothing
explain insert into test values(1, 0), (2, 0), (1, 0) on conflict do nothing
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp        3      0      0
 2             jmp_pop        0      0      0
 3              upsert        0      0      3
 4              upsert        0      3      3
 5              upsert        0      6      3
 6        cursor_close        0      0      0
 7                 ret        0      0      0

"
insert into test values(1, 0), (2, 0), (1, 0) on conflict do nothing
select * from test
[1, 0]
[2, 0]
drop table test
# test: upsert insert
create table test (id int primary key, data int)
explain insert into test values(1, 0) on conflict do update set data = data + 1
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp       14      0      0
 2         cursor_read        0      0      0
 3                push        0      0      0
 4                null        0      0      0
 5                push        0      0      0
 6          cursor_idx        0      0      1
 7                 int        1      1      0
 8                 add        2      0      1
 9                push        2      0      0
10              assign        0      3      1
11                push        0      0      0
12              update        0      0      0
13             jmp_pop        0      0      0
14              upsert        0      0      3
15        cursor_close        0      0      0
16                 ret        0      0      0

"
insert into test values(1, 0) on conflict do update set data = data + 1
select * from test
[1, 0]
drop table test
# test: upsert
create table test (id int primary key, data int)
insert into test values(1, 0) on conflict do update set data = data + 1
select * from test
[1, 0]
insert into test values(1, 0) on conflict do update set data = data + 1
select * from test
[1, 1]
insert into test values(1, 0) on conflict do update set data = data + 1
select * from test
[1, 2]
drop table test
# test: upsert batch
create table test (id int primary key, data int)
explain insert into test values (1, 0), (1, 0), (1, 0) on conflict do update set data = data + 1
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp       14      0      0
 2         cursor_read        0      0      0
 3                push        0      0      0
 4                null        0      0      0
 5                push        0      0      0
 6          cursor_idx        0      0      1
 7                 int        1      1      0
 8                 add        2      0      1
 9                push        2      0      0
10              assign        0      3      1
11                push        0      0      0
12              update        0      0      0
13             jmp_pop        0      0      0
14              upsert        0      0      3
15              upsert        0      3      3
16              upsert        0      6      3
17        cursor_close        0      0      0
18                 ret        0      0      0

"
insert into test values (1, 0), (1, 0), (1, 0) on conflict do update set data = data + 1
insert into test values (1, 0), (1, 0), (1, 0) on conflict do update set data = data + 1
insert into test values (1, 0), (1, 0), (1, 0) on conflict do update set data = data + 1
select * from test
[1, 8]
drop table test
# test: upsert where
create table test (id int primary key, data int)
insert into test values (1, 0) on conflict do update set data = data + 1
insert into test values (1, 0) on conflict do update set data = data + 1
insert into test values (1, 0) on conflict do update set data = data + 1
select * from test
[1, 2]
explain insert into test values (1, 0) on conflict do update set data = data + 1 where true
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp       16      0      0
 2                bool        0      1      0
 3            jntr_pop        0      0      0
 4         cursor_read        0      0      0
 5                push        0      0      0
 6                null        0      0      0
 7                push        0      0      0
 8          cursor_idx        0      0      1
 9                 int        1      1      0
10                 add        2      0      1
11                push        2      0      0
12              assign        0      3      1
13                push        0      0      0
14              update        0      0      0
15             jmp_pop        0      0      0
16              upsert        0      0      3
17        cursor_close        0      0      0
18                 ret        0      0      0

"
insert into test values (1, 0) on conflict do update set data = data + 1 where true
select * from test
[1, 3]
insert into test values (1, 0) on conflict do update set data = data + 1 where data < 3
select * from test
[1, 3]
insert into test values (1, 0) on conflict do update set data = data + 1 where data <= 3
select * from test
[1, 4]
drop table test
# test: upsert row access
create table test (id int primary key, data int)
insert into test values (1, 0) on conflict do update set data = data + 1
explain insert into test values (1, 123) on conflict do update set data = data + @[1]
"
bytecode [coordinator]
--------
 0                recv        0      0      0
 1                 ret        0      0      0


bytecode [shard 0]
--------
 0      cursor_prepare        0      -      0      # public.test
 1                 jmp       16      0      0
 2         cursor_read        0      0      0
 3                push        0      0      0
 4                null        0      0      0
 5                push        0      0      0
 6          cursor_idx        0      0      1
 7                 ref        1      0      0
 8                 int        2      1      0
 9                 idx        3      1      2
10                 add        1      0      3
11                push        1      0      0
12              assign        0      3      1
13                push        0      0      0
14              update        0      0      0
15             jmp_pop        0      0      0
16              upsert        0      0      4
17        cursor_close        0      0      0
18                 ret        0      0      0

"
insert into test values (1, 123) on conflict do update set data = data + @[1]
select * from test
[1, 123]
select *[1] from test
123
drop table test
# test: upsert row access #2
create table test (id int primary key, data int)
insert into test values (1, 0) on conflict do update set data = data + 1
select @ from test
query: on_error
{"code": 1, "msg": "@: reference is not defined"}
drop table test
# test: upsert error
create table test (id int primary key, data int)
insert into test values (1, 0), (2, 0), (3, null) on conflict do update set data = data + 1
select * from test
[1, 0]
[2, 0]
[3, null]
insert into test values (1, 0), (2, 0), (3, 0) on conflict do update set data = data + 1
query: on_error
{"code": 1, "msg": "bad + expression types"}
select * from test
[1, 0]
[2, 0]
[3, null]
drop table test
# test: upsert generate
create table test (id int primary key serial, data int default 0)
insert into test generate 10 on conflict do update set data = data + 1
select * from test
[0, 0]
[1, 0]
[2, 0]
[3, 0]
[4, 0]
[5, 0]
[6, 0]
[7, 0]
[8, 0]
[9, 0]
alter table test set serial = 0
insert into test generate 10 on conflict do update set data = data + 1
select * from test
[0, 1]
[1, 1]
[2, 1]
[3, 1]
[4, 1]
[5, 1]
[6, 1]
[7, 1]
[8, 1]
[9, 1]
drop table test
disconnect S0
env_close E0
