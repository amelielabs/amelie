open E0 "uuid": "00000000-0000-0000-0000-000000000000", "listen": [{ "host": "127.0.0.1", "port": 3485 }], "shards": 2
connect E0 S0 localhost:3485
# test: lambda parsing
select lambda
{"code": 1, "msg": "lambda <name> expected"}
select 1 lambda
{"code": 1, "msg": "lambda <name> expected"}
select lambda name
{"code": 1, "msg": "lambda name <(> expected"}
select lambda name -
{"code": 1, "msg": "lambda name <(> expected"}
select lambda name =
{"code": 1, "msg": "lambda name <(> expected"}
select lambda name (
{"code": 1, "msg": "bad expression"}
select lambda name ()
{"code": 1, "msg": "bad expression"}
select lambda name (true)
{"code": 1, "msg": "lambda name (expr) <=> expected"}
select lambda name (true) =
{"code": 1, "msg": "bad expression"}
# test: lambda (init)
select lambda n(false) = true from []
[false]
select lambda n(false) = true from [1]
[true]
select lambda n(null) = * from [1,2,3]
[3]
# test: lambda (state access)
explain select lambda n(123) = n from [1,2,3]
["
bytecode [coordinator]
--------
 0                 set        0      0      0
 1               group        1      0      0
 2                 int        2    123      0
 3           group_add        1      5      2
 4                null        3      0      0
 5                push        3      0      0
 6         group_write        1      0      0
 7                 int        3      1      0
 8                push        3      0      0
 9                 int        3      2      0
10                push        3      0      0
11                 int        3      3      0
12                push        3      0      0
13               array        3      3      0
14    cursor_open_expr        0      3     16
15                 jmp       20      0      0
16           group_get        4      1      0
17                push        4      0      0
18         group_write        1      0      0
19         cursor_next        0     16      0
20        cursor_close        0      0      0
21    cursor_open_expr        1      1     23
22                 jmp       26      0      0
23     group_read_aggr        3      1      0
24             set_add        0      3      0
25         cursor_next        1     23      0
26        cursor_close        1      0      0
27             cte_set        0      0      0
28                body        0      0      0
29                 ret        0      0      0

"]
select lambda n(123) = n from [1,2,3]
[123]
select lambda n([]) = n::append(*) from [1,2,3]
[[1, 2, 3]]
select lambda n([]) = n::append(*)::append(n) from [1,2,3]
[[1, [], 2, [1, []], 3, [1, [], 2, [1, []]]]]
select lambda n([]) = n::append(*)::append(n::string) from [1,2,3]
[[1, "[]", 2, "[1, "[]"]", 3, "[1, "[]", 2, "[1, "[]"]"]"]]
select * from (select lambda n([]) = n::append(*) from [1,2,3])
[[1, 2, 3]]
select lambda obj({}) = obj::set(*, [*]) from ["a", "b", "c"]
[{
  "a": ["a"],
  "b": ["b"],
  "c": ["c"]
}]
select lambda obj({}) = obj::set("key_" || *::string, *) from [1,2,3]
[{
  "key_1": 1,
  "key_2": 2,
  "key_3": 3
}]
# test: lambda (crosss state access)
select lambda i([]) = i::append(*), lambda j([]) = j::append(i) from [1,2,3]
[[[1, 2, 3], [[], [1], [1, 2]]]]
# test: lambda (label)
select (lambda n([]) = n::append(*)) as N from [1,2,3]
[[1, 2, 3]]
# test: lambda (group by)
select *, lambda n(0) = n + 1 from [1,2,2,3] group by *
[[1, 1], [2, 2], [3, 1]]
select *, lambda n([]) = n::append(*) from [1,2,2,3] group by *
[[1, [1]], [2, [2, 2]], [3, [3]]]
# test: lambda (shared table)
create shared table test (id int primary key)
[]
insert into test 1,2,3,4,5
[]
select lambda n([]) = n::append(id) from test
[[1, 2, 3, 4, 5]]
drop table test
[]
create shared table test (id int primary key, data int)
[]
insert into test values (0, 0)
[]
insert into test values (1, 1)
[]
insert into test values (2, 2)
[]
insert into test values (3, 1)
[]
insert into test values (4, 3)
[]
select lambda n([]) = n::append(data) from test
[[0, 1, 2, 1, 3]]
select data, lambda n([]) = n::append(id) from test group by data
[[0, [0]], [1, [1, 3]], [2, [2]], [3, [4]]]
drop table test
[]
# test: lambda (distributed table)
create distributed table test (id int primary key)
[]
insert into test 1,2,3,4,5
[]
select lambda n([]) = n::append(id) from test
{"code": 1, "msg": "operation not supported"}
explain select lambda n([]) = n::append(id) from test
["
bytecode [coordinator]
--------
 0            send_all        0      0      0
 1                recv        0      0      0
 2    group_merge_recv        0      0      0
 3                 set        2      0      0
 4    cursor_open_expr        1      0      6
 5                 jmp        9      0      0
 6     group_read_aggr        3      1      0
 7             set_add        2      3      0
 8         cursor_next        1      6      0
 9        cursor_close        1      0      0
10             cte_set        0      2      0
11                body        0      0      0
12                 ret        0      0      0


bytecode [node]
--------
 0               group        0      0      0
 1               array        1      0      0
 2           group_add        0      5      1
 3                null        2      0      0
 4                push        2      0      0
 5         group_write        0      0      0
 6             int_min        2      0      0
 7                push        2      0      0
 8         cursor_open        0      0     10      # public.test (primary)
 9                 jmp       18      0      0
10           group_get        2      0      0
11                push        2      0      0
12          cursor_idx        2      0      0
13                push        2      0      0
14                call        2      -      2      # public.append()
15                push        2      0      0
16         group_write        0      0      0
17         cursor_next        0     10      0
18        cursor_close        0      0      0
19              result        0      0      0
20                 ret        0      0      0

"]
drop table test
[]
# test: lambda (init exceptions)
create shared table test (id int primary key)
[]
insert into test 1,2,3,4,5
[]
select lambda n(id) = n::append(id) from test
{"code": 1, "msg": "cursor: cursor is not active"}
select lambda n(id) = 0
{"code": 1, "msg": "no targets to use with GROUP BY or aggregates"}
select lambda n(id) = 0 from [1,2,3]
{"code": 1, "msg": "cursor: cursor is not active"}
select lambda n(*) = 0 from [1,2,3]
{"code": 1, "msg": "*: not in active scan"}
# test: lambda (subquery)
select lambda n(select * from test) = n from [1, 2, 3]
[[[1], [2], [3], [4], [5]]]
select lambda n(select * from test) = n::append(*) from [1, 2, 3]
[[[1], [2], [3], [4], [5], 1, 2, 3]]
select lambda n(select id from test) = n::append(*) from [6, 7, 8]
[[1, 2, 3, 4, 5, 6, 7, 8]]
drop table test
[]
disconnect S0
close E0
